1) Capire il progetto di Jose
2) Scraping online, usirei Python (API se si trovano gratis?)
3) Rivedere l'idea, aggiungere query
4) Rivedere le collection
5) Scrivere il codice (Prima di scrivere si deve progettare qualcosina)

OSSERVAZIONI IMPORTANTI:
 - Il file index.jsp ha un refresh interno che chiama il servlet '/shop'
 - Il servlet '/shop' e' la classe controller.ShopServlet
 - Tale classe fa una richiesta usando DTO, poi inoltra il risultato alla pagina WEB-INF/template/shop.jsp
 - La pagina riceve un DTO e stampa il risultato
 - Tutte le pabine in WEB-INF/template sono appunto template che visualizzano i dati raccolti dai servlet nel package it.unipi.controller
 ---- DAO sono le classi usate nel back-end e nel trasferimento con i DBMS
 ---- DTO sono le classi usate esclusivamente per far interagire front-end e back-end

DETTAGLI:

1-	index.jsp chiama il servlet /shop (ShopServlet)
2-	ShopServlet quando viene chiamata chiama ProductService
3-	ProductService ritorna a /shop l'istanza (singleton?) di ProductServiceImpl
4-	ProductServiceImpl quando inizializzata la prima volta richiama DAOLocator
5-	DAOLocator ritorna quindi l'istanza singleton ProductMySQLDAO
6-	ProductServiceImpl richiama listProductPage che fa richiesta al DBMS
7-	ShopServlet ha ora una pageDTO che inoltra a shop.jsp
8-	shop.jsp riceve l'oggetto pageDTO e lo usa per popolare la pagina

RIGUARDO AI SERVLET:
> Parameter - Sono campi read only impostati da chi invia il pacchetto richiesta
> Attribute - Sono campi sia read che write, usati per mandare info nel frontend tra una pagina e laltra
> Session - Campo persistente delle richieste, contiene cose riguardande alla sessione tra host e server

---------------------
Cosa fare?
Campi con alcuni not exists
  - score
  - price_range

 --- > DA FARE SU MONGODB < ---
1) Funzione admin: se clicca il tasto, calcola il prezzo medio dei piatti nei ristoranti e aggiorna "price_range"
2) Funzione admin: se clicca il tasto, calcola il miglior ristorante per zip_code e aggiorna "position"
3) Funzione admin: se clicca il tasto, calcola lo score da neo4j e aggiorna lo score medio del ristorante su mongoDB

 --- > DA FARE SU JAVA < ---
1) Pagina commenti
2) Pagina admin per mettere le analytics in seguito
2) Pagina aggiunta piatti (Ristorante)
3) Pagina cerca e lista amici
4) Bottoni follow/unfollow
5) Sistema raccomandazioni (Neo4J)


---CAMPI COLLECTIONS MONGODB---

RESTAURANT - (  _id,
                position,
                nome,
                category,
                price_range,
                full_address,
                zip_code,
                lat,
                lon,
                dish[],   ------------------------------------------>    DISH - (  _id,
                email,                                                             category,
                password,                                                          name,
                pendingOrders[]  ------>  ORDER - (    _id,                        description,
                                                       user,                       price,
                                                                                   currency
                                                       paymentMethod             )
                                                       paymentNumber
                                                       address
                                                       zipcode
                                                       total
                                                       
                                                       currency
                                                       dishes[]       ------->     DISH - (  
                                                   )                                         name,
                                                                                             quantity
                                                                                           )

#######################################################################################################################

UTENTE - (   _id,
             firstname,
             lastname,
             username,
             email,
             phonenumber,
             address,
             zipcode,
             password,
             paymentMethod,
             paymentNumber
          )

########################################################################################################################

ORDINI - ( _id,
           user,
           restaurant,
           restaurantId,
           paymentMethod,
           paymentNumber,
           address,
           zipcode,
           total,
           status,
           dishes[]    --------->     DISH - (
         )                                      name,
                                                price,
                                                currency,
                                                quantity
                                              )




############################################ Ricevimento José #######################################################

1)  Spostare l'Admin in Users
        - Aggiungere un campo isAdmin
        - Adattare quesy su Admin.java

2)  Insert Order e Send Order in una transaction Mongo

3)  Model solo per bellezza!

4)  Ordini Fake Okay

5)  Modifica getRestaurantLogin() per evitare di chiedere i campi a seconda dei flag

6)  Valutare le performance della VM con htop

7)  Levare le Password nei DTO!

8)  OPTIONAL
        - Modifica piatti ristorante
        - WebSocket notifica nuovi ordini ricevuti dal ristorante





Cosiderazioni

1)  Composizione del nodo Restaurant
        - _id
        - Name
        - Zip_code
        - AVG(rate)

2)  I nodi Users vengono aggiunti quando un utente vota/recensisce un ristorante

3)  Consigliati
        - Schermare i ristoranti per zip_code della ricerca
        - Andare a guardare i ristoranti, in quel zip_code, che gli amici hanno recensito (bene?)
        - Se non trovo nessun ristorante, prendo i supernodi in quel zip_code

4)  Coordinare i vari database e mettere dati più "realistici"

5)  Demonde che aggiurna i valori fra MongoDB e Neo4J
